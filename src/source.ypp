%code requires {

#include <cstdlib>
#include <iostream>
#include <vector>
#include <unistd.h>

using namespace std;

#include "../include/ast"

int yylex();
int yylex_destroy();

}

%code {

    Stmt* tree;
    bool  error;
    bool showPrompt;

    extern FILE* yyin;
    extern int yylineno;

    void yyerror(const char* p) {
        if (!error) {
            cout << "[" << yylineno << "]err: " << p << endl;
            error = true;
        }
    }
}

%define parse.error verbose

%union {
    Block* block;
    Stmt*  stmt;
    Exp*   exp;
    Id*    id;
    Oper   op;
    vector<Id*> *arr;
    vector<Exp*> *arrE;
    vector<dict*> *arrDefs;
    dict* adict;
};

%left<op> BOP
%right<op> NOTTOK
%left<op> COMP
%left<op> OPA
%left<op> OPM
%right POSNEG

%token LC RC LP RP FUNC IF ELSE FOR READ PRINT PRINTLN LET ASN STOP COMA IN RANGE USE EXIT COLON CONT FROM
%token<id> ID
%token<exp> INT FLOAT BOOL STRING
%token<stmt> DEBUG arg
%type<stmt> stmt stmtlist
%type<block> block rawblock
%type<exp> exp
%type<arr> args
%type<arrE> exps
%type<adict> arg_def
%type<arrDefs> arg_defs

%destructor { delete $$; } <block>
%destructor { delete $$; } <stmt>
%destructor { delete $$; } <exp>
%destructor { delete $$; } <id>

%%

res: stmt { $1->set_next(new NullStmt); tree = $1; YYACCEPT; }
|         { }

stmtlist: stmt stmtlist             { $1->set_next($2); $$ = $1; }
|                                   { $$ = new NullStmt; }

stmt: EXIT STOP                     {$$ = new ExitStmt(); }
|     USE ID STOP                   {$$ = new UseStmt($2);}
|     LET ID ASN exp STOP           {$$ = new LetStmt($2,$4);}
|     ID ASN exp STOP               {$$ = new Assign($1,$3);}
|     PRINT LP exps RP STOP         {$$ = new Print($3);}
|     PRINTLN LP exps RP STOP       {$$ = new PrintLn($3);}
|     IF exp block                  {$$ = new IfStmt($2,$3,new NullStmt);}
|     IF exp block ELSE block       {$$ = new IfStmt($2,$3,$5);}
|     FOR exp block                 {$$ = new ForStmt($2,$3);}
|     FOR ID IN RANGE exp block     {$$ = new ForStmt($2, $5, $6);}
|     rawblock                      {$$ = $1;}
|     exp STOP                      {$$ = new ExpStmt($1);}

block: rawblock                     {$1->set_next(new NullStmt); $$ = $1; }
rawblock: LC stmtlist RC            {$$ = new Block($2); }

exp: exp BOP exp                    {$$ = new Boolean($1 ,$2, $3);}
|    NOTTOK exp                     {$$ = new NotOper($2);}
|    exp COMP exp                   {$$ = new Compare($1, $2, $3);}
|    exp OPA exp                    {$$ = new Binary($1,$2,$3);}
|    exp OPM exp                    {$$ = new Binary($1,$2,$3);}
|    OPA exp %prec POSNEG           {$$ = ($1 == ADD ? $2 : new Negation($2));}
|    READ                           {$$ = new Read();}
|    exp LP exps RP                 {$$ = new FunCall($1,$3);}
|    FUNC args block                {$$ = new Func($2,$3);}
|    CONT LC arg_defs RC            {$$ = new Cont($3);}
|    ID FROM ID                     {$$ = new ContEval($1, $3);}
|    ID                             {$$ = $1;}
|    INT                            {$$ = $1;}
|    FLOAT                          {$$ = $1;}
|    STRING                         {$$ = $1;}
|    BOOL                           {$$ = $1;}

exps:   exps COMA exp               {$$ = $1; $1->push_back($3);}
|       exp                         {$$ = new std::vector<Exp*>(); $$->push_back($1);}

args:   args COMA ID                {$$ = $1; $1->push_back($3);}
|       ID                          {$$ = new std::vector<Id*>(); $$->push_back($1);}


arg_defs: arg_defs COMA arg_def     {$$ = $1; $1->push_back($3);}
|         arg_def                   {$$ = new std::vector<dict*>(); $$->push_back($1);}

arg_def:    ID COLON exp            {$$ = new dict($1, $3);}

%%
