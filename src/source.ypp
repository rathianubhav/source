%code requires {

#include <cstdlib>
#include <iostream>
#include <vector>
#include <unistd.h>

using namespace std;

#include "../include/ast"

int yylex();
int yylex_destroy();

}

%code {

    Stmt* tree;
    bool  error;
    bool showPrompt;

    extern FILE* yyin;
    extern int yylineno;

    void yyerror(const char* p) {
        if (!error) {
            cout << "[" << yylineno << "]err: " << p << endl;
            error = true;
        }
    }
}

%define parse.error verbose

%union {
    Block* block;
    Stmt*  stmt;
    Expr*   expr;
    Id*    id;
    Oper   op;
    vector<Id*> *arr;
    vector<Expr*> *arrE;
    vector<dict*> *arrDefs;
    dict* adict;
};

%left<op> BOP
%right<op> NOTTOK
%left<op> COMP
%left<op> OPA
%left<op> OPM
%right POSNEG

%token LC RC LP RP FUNC IF ELSE FOR READ PRINT PRINTLN LET ASSIGN STOP COMA IN RANGE USE EXIT COLON CONT FROM
%token<id> ID
%token<expr> INT FLOAT BOOL STRING
%token<stmt> DEBUG arg
%type<stmt> stmt stmts 
%type<stmt> if_stmt for_stmt print_stmt assign_stmt use_stmt block_stmt expr_stmt
%type<block> block rawblock
%type<expr> expr values container_eval 
%type<arr> args
%type<arrE> exprs
%type<adict> arg_def
%type<arrDefs> arg_defs

%destructor { delete $$; } <block>
%destructor { delete $$; } <stmt>
%destructor { delete $$; } <expr>
%destructor { delete $$; } <id>

%%

res
: stmt { $1->set_next(new NullStmt); tree = $1; YYACCEPT; }
|         { }
;

stmts
: stmt stmts { $1->set_next($2); $$ = $1; }
| { $$ = new NullStmt; }
;

stmt
: use_stmt
| assign_stmt
| print_stmt
| if_stmt
| for_stmt
| block_stmt
| expr_stmt                    

use_stmt
:   USE ID STOP {$$ = new Use($2);}

assign_stmt
:   LET ID ASSIGN expr STOP  {$$=new Let($2, $4);}
|   ID ASSIGN expr STOP  {$$=new Assign($1, $3);}
;

print_stmt
:   PRINT LP exprs RP STOP  {$$=new Print($3);}
|   PRINTLN LP exprs RP STOP {$$=new PrintLn($3);}
;

if_stmt
:   IF expr block    {$$ = new If($2, $3);}
|   IF expr block ELSE block {$$ = new If($2, $3, $5);}
;

for_stmt
:   FOR expr block   {$$ = new For($2, $3);}
|   FOR ID IN RANGE expr block {$$=new For($2, $5, $6);}
;

block_stmt
:   rawblock {$$=$1;}
;

expr_stmt
:   expr STOP {$$ = new ExprStmt($1);}
;



block
: rawblock {$1->set_next(new NullStmt); $$ = $1; }
;

rawblock
: LC stmts RC {$$ = new Block($2); }
;

expr
: expr BOP expr                    {$$ = new Boolean($1 ,$2, $3);}
|    NOTTOK expr                     {$$ = new NotOper($2);}
|    expr COMP expr                   {$$ = new Compare($1, $2, $3);}
|    expr OPA expr                    {$$ = new Binary($1,$2,$3);}
|    expr OPM expr                    {$$ = new Binary($1,$2,$3);}
|    OPA expr %prec POSNEG           {$$ = ($1 == ADD ? $2 : new Negation($2));}
|    READ                           {$$ = new Read();}
|    ID LP exprs RP                  {$$ = new Call($1,$3);}
|    FUNC args block                {$$ = new Func($2,$3);}
|    CONT LC arg_defs RC            {$$ = new Cont($3);}
| container_eval
| values
;


container_eval
: ID FROM ID {$$=new ContainerEval($1, $3);}
;



values
: ID {$$ = $1;}
| INT {$$ = $1;}
| FLOAT {$$ = $1;}
| STRING {$$ = $1;}
| BOOL {$$ = $1;}
;

exprs
: exprs COMA expr {$$ = $1; $1->push_back($3);}
| expr {$$ = new std::vector<Expr*>(); $$->push_back($1);}
;

args
: args COMA ID {$$ = $1; $1->push_back($3);}
| ID {$$ = new std::vector<Id*>(); $$->push_back($1);}
;

arg_defs
: arg_defs COMA arg_def {$$ = $1; $1->push_back($3);}
| arg_def {$$ = new std::vector<dict*>(); $$->push_back($1);}
;


arg_def
: ID COLON expr {$$ = new dict($1, $3);}
;

%%
